// Anton Appel le 15 avril 2023
// Une simple modification de la librairie 'list.wati'
// permettant d'avoir une vérification de types lors de la manipulation de la liste
// On déclare donc une nouvelle liste en spécifiant le type, exemple :
// T = Tlist("char");
// T = T + "premier element";
// 
// Ou encore
// T = Tlist("int");
// T = T + 1 + 2 + 3;
// !println(T) >> [1, 2, 3]

inclue "node.wati";

classe Tlist contient 
    // Une liste doublement chaînée
    // Contient des éléments de type spécifié

    methode constructeur (l_type) fait
        self.head = node("debut-de-liste");
        self.tail = node("fin-de-liste");
        self.head.next = self.tail;
        self.tail.prev = self.head;

        self.taille = 0;
        self.accession = !self.accede;
        self.l_type = l_type;
    fin

    methode optimise () fait
        "Optimise cette liste pour avoir un algorithme 'doublement chaîné'. Peut affecter les performances selon le langage."
        // Ne modifie que la manière dont la liste est accédée
        self.accession = !self.accede_opti;
    fin

    methode plus(content) fait
        si !type(content) != self.l_type alors
            !erreur("!list.plus : Tlist(" + self.l_type + ") ne supporte pas le type " + !type(content))
        fin
        n = node(content);
        n.next = self.tail;
        
        prev = self.tail.prev;
        n.prev = prev;
        prev.next = n;
        self.tail.prev = n;
        
        self.taille = self.taille + 1;
        renvoie self;
    fin

    methode debut(content) fait
        n = node(content);
        r = self.head.next;
        r.prev = n;
        n.next = r;
        self.head.next = n;
        n.prev = self.head;
        self.taille = self.taille + 1;
        renvoie self;
    fin

    methode accede_opti(index) fait 
        p1 = 0;
        p2 = self.taille;
        si !ou(index >= p2, -index >= p2) alors
            !erreur("!list : l'index est plus grand que la taille de la liste")
        fin
        si index < 0 alors
            index = self.taille + index;
        fin
        si index < (self.taille - index) alors
            m = !self.head.chaine(0, index + 1);
        sinon
            m = !self.tail.chaine(p2, index);
        fin
        renvoie m;
    fin

    methode accede (index) fait
        m = self.head;
        pour i allant de 0 a (index + 1) fait
            m = m.next;
        fin
        renvoie m;
    fin

    methode modifie (index, content) fait
        si !type(content) != self.l_type alors
            !erreur("!list.plus : Tlist(" + self.l_type + ") ne supporte pas le type " + !type(content))
        fin
        n = !self.accession(index);
        n.content = content;
    fin

    methode en_string() fait
        si self.taille == 0 alors
            renvoie "[ ]";
        fin

        r = "[ ";
        n = self.head.next;

        tant que (n.next.content != self.tail.content) fait
            si !type(n.content) == "char" alors
                r = r + "'" + n.content + "'" + ", ";
            sinon
                r = r + !char(n.content) + ", ";
            fin
            n = n.next;
        fin
        
        si !type(n.content) == "char" alors
            r = r + "'" + n.content + "' ]";
        sinon
            r = r + !char(n.content) + " ]";
        fin
        
        renvoie r;
    fin

    methode en (x) fait
        si (!type(x) != "int") alors
            !erreur("list : le type 'list' n'accepte d'indexation que avec le type 'int', pas '"+!type(x)+"'")
        fin
        
        si (x >= self.taille) fait
            !erreur("list : l'index est plus grand que la taille de la liste");
        fin

        renvoie (!self.accession(x)).content;
    fin

    methode index (x) fait
        renvoie !self.en(x);
    fin
    
    methode pop (x) fait
        i = 0;
        si (self.taille <= 0) alors
            !erreur("list : ne peut pas pop depuis une liste vide")
        fin

        si (x >= self.taille) alors
            !erreur("list : l'index est plus grand que la taille de la liste")
        fin

        n = !self.accession(x);
        
        p = n.prev;
        next = n.next;
        p.next = next;
        next.prev = p;
        self.taille = self.taille - 1;
        u = n.content;
        libere n;
        renvoie u;
    fin

    methode envers () fait
        l = list();
        pour i allant de 0 a self.taille fait
            !l.debut(!self.en(i))
        fin
        renvoie l;
    fin

    methode destructeur () fait
        to_d = self.head.next;
        si (to_d.content == "fin-de-liste") fait
            libere self.head;
            libere self.tail;
            renvoie;
        fin
        tant que to_d.next.content != self.tail.content fait
            p = to_d;
            to_d = to_d.next;
            libere p;
        fin
        libere self.head;
    fin

    methode ne (x) fait
        "Support de la syntaxe 'list != list'"
        // On utilise juste la syntaxe prédéfinie dans equals
        renvoie !pas(!self.equals(x));
    fin

    methode equals (x) fait
        "Support de la syntaxe 'list == list'"
        si !type(x) != "list" alors
            renvoie 0;
        fin
        // Doivent être évidemment de la même taille
        si x.taille != self.taille alors 
            renvoie 0;
        fin

        // On cheque noeuds après noeuds si le contenu est le même
        // Peut être récursif si il y a des sous listes
        m = self.head;
        n = x.head;
        pour i allant de 0 a self.taille fait
            m = m.next;
            n = n.next;
            si m.content != n.content alors 
                renvoie 0;
            fin
        fin
        renvoie 1;
    fin
fin