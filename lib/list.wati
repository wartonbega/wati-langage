// Anton Appel le 15 avril 2023
// Un liste en wati est doublement chainée
// Elle peut utiliser deux algorithmes d'accéssion : 
// 1. par méthode directe, c'est-à-dire que on part du début pour arriver à l'index demandé
// 2. par la méthode doublement chainée, on pars du point le plus près (début ou fin) pour arriver a l'élement demandé.
// Cette optimisation est possible en modifiant la liste (on utilisera donc la méthode 'optimise')
//
// Attention : des performances peuvent être perdues en utilisant la seconde méthode puisqu'il y a plus de comparaisons
//
// Les listes ne sont pas typées donc il appartient à l'utilisateur de faire attention aux types utilisés
// Une liste avec type (Tlist) existe dans la biliothèque standard
// 
// La taille de la liste n'est pas recomptée à chaques demande de la taille, 
// mais elle est gardée comme attribut et incrémentée/décrémentée à chaques modification.
// Cela implique que des modifications 'manuelles' par l'utilisateur peuvent empêcher le bon fonctionnement de cette liste

inclue "node.wati";

classe list contient 
    // Une liste doublement chaînée
    // Contient des éléments de type non spécifié

    methode constructeur () fait
        self.head = node("debut-de-liste"); 
        self.tail = node("fin-de-liste");
        self.head.next = self.tail;
        self.tail.prev = self.head;

        self.taille = 0; // La taille qui vas être incrémentée
        self.accession = !self.accede; // La methode d'accès à un element
    fin

    methode optimise () fait
        "Optimise cette liste pour avoir un algorithme 'doublement chaîné'. Peut affecter les performances selon le langage."
        // Ne modifie que la manière dont la liste est accédée
        // Les performances gagnées par la complexité de l'algorithme peuvent être perdues en termes de comparaison et de calcules
        self.accession = !self.accede_opti;
    fin

    methode plus(content) fait
        "Ajoute une élément à la fin de liste"

        // On fabrique un nouveau noeud à partir de content
        n = node(content);

        // L'élément d'après est la fin de la liste tandisque 
        // l'élément d'avant est celui qui précédais la liste
        n.next = self.tail;
        prev = self.tail.prev;
        n.prev = prev;

        // On glisse modifie finalement les elements avant et après pour 
        // compléter le double chaînage
        prev.next = n;
        self.tail.prev = n;
        
        // Incrémente la taille pour ne pas à avoir à la recalcuer systématiquement
        self.taille = self.taille + 1;

        // Permet la synttaxe du type
        // !list.plus(1).!plus(2)
        renvoie self;
    fin

    methode debut(content) fait
        "Insert un élément au début de la liste"

        // Crée un nouveau noeud
        n = node(content);

        // Place le noeud dans la liste
        r = self.head.next;
        r.prev = n;
        n.next = r;
        self.head.next = n;
        n.prev = self.head;

        // Incrémente la taille
        self.taille = self.taille + 1;
        renvoie self;
    fin

    methode accede_opti(index) fait 
        "Accession à un élément donné (par l'index), en utilisant l'algorithme de double chaînage"
        // Algorithme simplifié :
        // On compare la distance à l'index donné du début et de la fin.
        // Si le point est plus près de la fin, alors on vient à rebours, 'remonter' la liste
        // sinon on part du début et on déroule la liste.
        // On utilise dans les deux cas la récursion vis à vis de la méthode 'chaine' de node. (Potentielle perte de mémoire à ce niveau)

        // On utilise comme référence les deux points p1 (début) et p2 (fin)
        p1 = 0;
        p2 = self.taille;
        
        // On vérifie que l'index est valide
        si !ou(index >= p2, -index >= p2) alors
            !erreur("!list : l'index est plus grand que la taille de la liste")
        fin

        // De toute façon, accéder à un index négatif reviens à acceder a l'index positif en partant de la fin
        si index < 0 alors
            index = self.taille + index;
        fin
        
        // On utilise bien le point le plus proche
        si index < (self.taille - index) alors
            m = !self.head.chaine(0, index + 1);
        sinon
            m = !self.tail.chaine(p2, index);
        fin

        renvoie m; // On renvoi le node et pas son contenu
    fin

    methode accede (index) fait
        "On accède à un élément de la liste (donné par index)" 
        // Algorithme basique, itératif et sans optimisation de l'algorithme
        m = self.head;
        pour i allant de 0 a (index + 1) fait
            m = m.next;
        fin
        renvoie m;
    fin

    methode modifie (index, content) fait
        "Modifie le contenue de l'élément à l'endroit demandé. Compatible avec la syntaxe 'list[index] = content'"
        n = !self.accession(index);
        n.content = content;
    fin

    methode en_string() fait
        "Renvoie la liste sous forme de chaîne de caractère : [e1, e2, ..., en]"
        // Méthode itérative et un peut bourinne
        si self.taille == 0 alors
            renvoie "[ ]";
        fin

        // On construit la chaîne élément par élément, en le mettant en string.
        // Si l'élément est de type char, alors on rajoute des apostrophes autours
        // Sinon on rajoute juste une virgule jusqu'à l'avant dernier element
        // peut être recursif si sous liste

        r = "[ ";
        n = self.head.next;

        tant que (n.next.content != self.tail.content) fait
            si !type(n.content) == "char" alors
                r = r + "'" + n.content + "'" + ", ";
            sinon
                r = r + !char(n.content) + ", ";
            fin
            n = n.next;
        fin
        
        si !type(n.content) == "char" alors
            r = r + "'" + n.content + "' ]";
        sinon
            r = r + !char(n.content) + " ]";
        fin
        
        renvoie r;
    fin

    methode en (x) fait
        "Methode pour la syntaxe : 'liste[index]'"
        si (!type(x) != "int") alors
            !erreur("list : le type 'list' n'accepte d'indexation que avec le type 'int', pas '"+!type(x)+"'")
        fin
        
        si (x >= self.taille) fait
            !erreur("list : l'index est plus grand que la taille de la liste");
        fin
        // La méthode utilisé pour acceder au noeud requis est celle qui a été spécifé
        renvoie (!self.accession(x)).content;
    fin

    methode index (x) fait
        // Inutile ?
        renvoie !self.en(x);
    fin
    
    methode pop (x) fait
        "Enlève le n-ième élément de la liste et le renvoie"

        si (self.taille <= 0) alors
            !erreur("list : ne peut pas pop depuis une liste vide")
        fin

        si (x >= self.taille) alors
            !erreur("list : l'index est plus grand que la taille de la liste")
        fin

        // On accede a l'element demandé avec la méthode spécifé
        n = !self.accession(x);

        // On raccorde les différents noeuds
        p = n.prev;
        next = n.next;
        p.next = next;
        next.prev = p;
        self.taille = self.taille - 1;
        u = n.content;
        libere n;
        renvoie u;
    fin

    methode envers () fait
        "Renvoie une liste à l'envers. Ne modifie pas la liste de départ."
        // On retourne la liste : une liste type 
        // [1, 2, 3, 4] devient [4, 3, 2, 1]
        // Cependant : requiers la construction d'une nouvelle liste
        l = list();
        pour i allant de 0 a self.taille fait
            !l.debut(!self.en(i))
        fin
        renvoie l;
    fin

    methode destructeur () fait
        // Libère la mémoire allouée pour chaques nodes utilisées dans la liste
        // Attention, peut créer des erreurs de déalocation liée au cpp
        to_d = self.head.next;

        // Deux cas possibles :
        // La liste est vide ou non
        si (to_d.content == "fin-de-liste") fait
            libere self.head;
            libere self.tail;
            renvoie;
        fin

        // Si la liste n'est pas vide, alors on ne se contente pas de libérer le début et la fin
        tant que to_d.next.content != self.tail.content fait
            p = to_d;
            to_d = to_d.next;
            libere p;
        fin
        // Le seul qui n'a pas été libéré
        libere self.head;
    fin

    methode ne (x) fait
        "Support de la syntaxe 'list != list'"
        // On utilise juste la syntaxe prédéfinie dans equals
        renvoie !pas(!self.equals(x));
    fin

    methode equals (x) fait
        "Support de la syntaxe 'list == list'"
        si !type(x) != "list" alors
            renvoie 0;
        fin
        // Doivent être évidemment de la même taille
        si x.taille != self.taille alors 
            renvoie 0;
        fin

        // On cheque noeuds après noeuds si le contenu est le même
        // Peut être récursif si il y a des sous listes
        m = self.head;
        n = x.head;
        pour i allant de 0 a self.taille fait
            m = m.next;
            n = n.next;
            si m.content != n.content alors 
                renvoie 0;
            fin
        fin
        renvoie 1;
    fin
fin